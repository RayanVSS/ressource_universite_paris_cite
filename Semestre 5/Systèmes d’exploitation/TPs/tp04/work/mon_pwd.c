#define _ATFILE_SOURCE
#define _DEFAULT_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <dirent.h>
#include <string.h>
#include <limits.h>
#include <fcntl.h>
#include <errno.h>
#include <features.h>

//ATTENTION: si le répertoire courant est toujours ./
//la variable courant elle correspond à un chemin du style "./../.."
//qui évoluera au fur et au mesure qu'on remonte à la racine.

//On limitera les tailles des chemins PATH_MAX

//retourne le nom du répertoire correspondant au chemin courant
char *nom_du_repertoire(char * courant) {
	struct stat a  ; 
	struct stat tmp  ; 
	int ret = stat(courant , &a) ;
	char pere[strlen(courant)+4] ;
	strcpy(pere , courant) ; 
	strcat(pere , "/..") ; 
	DIR * dirp = opendir(pere) ; 
	struct dirent * entry = NULL ; 
	while ((entry = readdir(dirp)) != NULL) {
		if (fstatat(dirfd(dirp) , entry->d_name , &tmp , AT_SYMLINK_NOFOLLOW) != 0) {
			closedir(dirp) ; 
			return NULL ; 
		}
		if (entry->d_ino == a.st_ino) {
			char * res = malloc((strlen(entry->d_name)+1)*sizeof(char)) ; 
			res = strcpy(res , entry->d_name) ; 
			closedir(dirp) ; 
			return res ; 
		}
	}
}


//est-ce que le répertoire correspondant au chemin courant
//est la racine
int est_racine(char * courant) {
	struct stat courantInfo ; 
	struct stat pereInfo ; 
	if (stat(courant , &courantInfo) != 0) {
		return -1 ; 
	}
	char pere[strlen(courant)+4] ; 
	strcpy(pere , courant) ; 
	strcat(pere , "/..") ; 
	if (stat(pere , &pereInfo) != 0) {
		return -1 ; 
	}
	return (courantInfo.st_ino == pereInfo.st_ino)?0:1 ; 
}



//c'est là qu'on fait la récursion
char *  construit_chemin_aux(char * courant, char * pwd) {
	switch (est_racine(courant)) {
	case 0: return pwd ; 
	case -1 : return NULL ;
	default:
		char pere[strlen(courant)+4] ; 
		strcpy(pere , courant) ; 
		strcat(pere , "/..") ; 
		char * res = construit_chemin_aux(pere,pwd) ; 
		char * nameCourant = nom_du_repertoire(courant) ; 
		res = strcat(res , "/") ; 
		res = strcat(res , nameCourant) ; 
		free(nameCourant) ; 
		return res ; 
	}
}

//cette fonction retournera la référence absolue du répertoire courant ./
char *  construit_chemin() {
  //pwd est un chemin de style "/bidule/truc" où "bidule/truc" est la fin du pwd, à la fin ce sera le pwd
  char *  pwd = malloc (PATH_MAX* sizeof(char));
  // courant est un chemin du style "./../.."
  char *courant = malloc (PATH_MAX* sizeof(char));
  
  sprintf(courant,"."); 
  sprintf(pwd,"/");

  pwd = construit_chemin_aux(courant, pwd);

  free(courant);

  return pwd;
}

void fileType (struct stat *buff) {
    switch (buff->st_mode & __S_IFMT) {
  case __S_IFREG:
    printf("type => Reg File\t") ; 
    break;
  case __S_IFDIR :
    printf("type => Directory\t") ; 
    break; 
  case __S_IFLNK :
    printf("type => Link\t") ; 
    break;  
  default: printf("type => Autre\t") ; 
    break;
  }
}

void fileExec (struct stat *buff) {
  if (buff->st_mode & S_IXUSR || buff->st_mode & S_IXGRP || buff->st_mode & S_IXOTH) {
    printf("Executable par u || g || o\n") ; 
    return ; 
  }
  printf("Non Executable\n") ;   
}

void ls_a (char * dir) {
	DIR* doss = opendir(dir) ; 
	if (doss == NULL) return ;
	struct dirent * tmp = NULL ; 
	errno = 0 ; 
	while ((tmp = readdir(doss)) != NULL) {
		printf("%s  " , tmp->d_name) ; 
	}
	if (errno != 0) {
		closedir(doss) ; 
		return ; 
		// going to clean or go to ret value
	}
	closedir(doss) ; 
}

void ls_i_sz (char * dir) {
	DIR* doss = opendir(dir) ; 
	struct stat info ; 
	if (doss == NULL) return ;
	struct dirent * tmp = NULL ; 
	while ((tmp = readdir(doss)) != NULL) {
		if (stat(tmp->d_name , &info) != 0) {
			closedir(doss) ; 
		return ; 
		} 
		printf("size => %lu | inoeud => %lu | name => %s \n" ,  info.st_size , tmp->d_ino , tmp->d_name) ; 
	}
	closedir(doss) ; 
}

void ls_all (char ** dir , size_t size) {
	for (size_t i = 0 ; i<size ; i++) {
		printf("dossier %zu => %s" , i , *(i+dir)) ; 
		ls_a(*(i+dir)) ; 
		puts("") ; 
	}
}

int main(int argc, char **argv) { 
	char * res = construit_chemin(argv[1]) ;
	printf("pwd(%s) => %s\n" , argv[1] , res) ;  
	free(res) ; 
	//ls_i_sz(argv[1]) ; 
	
	//ls_a(argv[1]) ; 
	// if (ret < 0) {
	//   perror("ref invalide") ; 
	//   return -1 ;
	// }
	// fileType(&buff) ; 
	// fileExec(&buff) ; 
	
	// printf("inoeud => %ld\n" , buff.st_ino ) ; 
	// char * pwd;
	
	// pwd = construit_chemin();
	// printf("%s\n", pwd);
	// free(pwd);
	return 0;  
}

