TP nº10 : signaux
==================

**L3 Informatique - Système**

Le but de ce TP est d'effectuer quelques manipulations simples pour mieux
comprendre la gestion des signaux.

Une bonne référence est la page `man 7 signal`, très fournie -- en fait,
nettement plus que nécessaire pour ce TP : en dehors des commandes et
fonctions usuelles, vous n'aurez besoin que de la commande `kill` (`man
kill`), et des appels système `kill()` (`man 2 kill`), `pause()` et
`sigaction()`. 


#### Exercice 1 : la belle au bois dormant

* Écrire (en C) un programme qui dort (en faisant une boucle de `pause()`
  par exemple) en ignorant tous les signaux (du moins, ceux qu'il peut
  ignorer). 

  Vérifier que votre programme se comporte comme attendu en lui envoyant
  divers signaux avec la commande `kill`, en terminant par `SIGKILL`.

* Modifier votre programme pour qu'il dorme seulement jusqu'à réception
  du signal `SIGUSR1`, et ~~se réveille~~ termine alors.

* Modifier enfin votre programme pour qu'il dorme jusqu'à réception de
  __deux__ signaux `SIGUSR1` : lorsqu'il reçoit un premier ~~baiser~~
  signal `SIGUSR1`, il ~~frissonne~~ affiche `"Humm..."`, puis en attend
  un second pour afficher `"Merci mon prince!"` (puis termine).


#### Exercice 2 : signaux *vs* `exec()`

* À partir d'un terminal, lancer un processus s'exécutant dans une
  fenêtre externe (type `xeyes`), puis fermer le terminal en cliquant sur
  la petite croix en haut : vous devriez constater que le processus
  précédent s'arrête en même temps.

* Recommencer en utilisant la commande `nohup` pour lancer la même
  commande, et constater que cette fois, le processus survit au terminal.
  Consulter `man nohup` si vous avez besoin de vous rafraichir la
  mémoire à son sujet.

* L'arrêt du processus dans le premier cas (sans utilisation de `nohup`)
  est dû à la réception un signal. Déterminer lequel en comparant la
  sortie de `strace sleep 5` et `strace nohup sleep 5` dans 2 terminaux
  différents (en commençant la comparaison vers la fin, ce qui est
  intéressant se trouve entre les `fcntl` et le point de divergence).

* Écrire un programme reproduisant le comportement de la commande
  `nohup` en vous inspirant de ce que vous avez vu dans `strace nohup
  sleep 5`.

* Est-il possible de faire en sorte que le programme ajoute la ligne
  `"signal SIGHUP reçu"` dans le fichier `nohup.out`?



#### Exercice 3 : une petite course (lente)

* Écrire un programme qui crée dix processus, un père et ses 9 fils.  Le
  père envoie ensuite le signal `SIGUSR1` à tous ses fils (en même temps)
  pour lancer le départ (noter qu'ils appartiennent tous au même groupe,
  dont l'identifiant est le `pid` du père).

  À la réception de `SIGUSR1`, chaque processus (père et fils) initialise
  un compteur à 0, puis, en boucle infinie :

	* s'endort pour une durée aléatoire comprise entre 1 et 3 secondes,

	* puis incrémente son compteur.
	
  Lorsqu'un processus reçoit le signal `SIGINT`, il affiche son pid et
  la valeur de son compteur, puis poursuit.
 
* Tester votre programme : vérifier notamment que le signal `SIGUSR1` n'a
  tué personne, puis que les processus réagissent comme attendu à
  `SIGINT`. Comparer l'envoi de `SIGINT` sélectivement à un processus
  (grâce à la commande `kill`), ou à tous les processus par la saisie de
  `ctrl-C` dans le terminal. Terminer en envoyant `SIGKILL` à tous les
  processus.

* Modifier votre programme pour en faire une course : le premier processus 
  à atteindre 20 a gagné. Il envoie alors le signal `SIGUSR2` aux autres
  processus, affiche son pid suivi de `"Gnark, j'ai gagné !"` puis termine.
  À la réception de `SIGUSR2`, tous les autres processus affichent leur pid, 
  suivi de `"Ah, j'ai perdu !"`, puis terminent.

* Que peut-il se passer si les gestionnaires de signaux des fils ne sont
  pas en place dès leur création?



#### Exercice 4 : processus à l'arrière-plan et accès au terminal

Écrire un programme `test-tty.c` qui :
* met en place, pour tous les signaux possibles, un gestionnaire
  affichant **sur la sortie erreur** le numéro du signal reçu;
* tente de lire quelques caractères sur l'entrée standard (avec `read`);
* tente d'écrire un caractère sur la sortie standard (avec `write`).

Chaque tentative de lecture ou écriture sera précédée et suivie de
l'affichage d'un message informatif **sur la sortie erreur**.

Tester ensuite ce programme successivement dans chacune des trois
situations suivantes, en redirigeant la sortie erreur sur un **autre**
terminal :
* exécution à l'avant-plan;
* exécution à l'arrière-plan dans un terminal réglé **sans** l'option
  `tostop`;
* exécution à l'arrière-plan dans un terminal réglé **avec** l'option
  `tostop`.

_Pour rappel, les réglages du terminal peuvent être consultés ou modifiés
grâce à la commande `stty` : `stty -a` pour afficher tous les réglages,
`stty tostop` ou `stty -tostop` pour mettre ou enlever l'option
`tostop`._

Ces tests doivent vous permettre de déterminer les signaux utilisés par
le système pour notifier les tentatives illicites d'accès au terminal, en
lecture ou en écriture.

Modifier maintenant `test-tty.c` pour :
* remettre en place les gestionnaires par défaut pour les deux signaux
  impliqués _(et seulement pour eux -- en tout cas il est important sous
  linux de continuer à capter `SIGCONT`)_;
* tenter à nouveau une lecture et une écriture.

Tester à nouveau l'exécution à l'arrière-plan dans un terminal avec
l'option `tostop`. À chaque fois que nécessaire, relancer le processus
suspendu (avec `bg`, ou `kill -CONT [pid]`).


