#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <errno.h>

volatile sig_atomic_t sigusr1 = 0;

void handler1 (int sig) {
    sigusr1 = 1;
}

// void f () {
//     pid_t pid ;
//     for (int i = 0 ; i<3 ; i++) {
//         pid = fork();
//         switch (pid) {
//             case 0:
//                 execlp("sleep", "sleep", "1", NULL);
//                 perror("execlp");
//             case -1:
//                 perror("fork");
//                 exit(EXIT_FAILURE);
//             default:
//                 break;    
//         }
//     }
//     errno = 0 ; 
//     do {
//         wait(NULL) ; 
//     }while(errno != ECHILD) ;
//     sleep(10) ; 
// }

int main(int argc, char const *argv[]){
    struct sigaction action = {0};
    action.sa_handler = handler1 ; 
    sigaction(SIGUSR1, &action, NULL);

    // Block SIGUSR1
    sigset_t mask, oldmask;
    sigemptyset(&mask);
    sigaddset(&mask, SIGUSR1);
    sigprocmask(SIG_BLOCK, &mask, &oldmask);

    pid_t pid ; 
    for (int i = 0 ; i<5 ; i++) {
        pid = fork();
        switch (pid) {
            case 0:
                int nb = 0 ; 
                while(nb <= i) {
                    // Unblock SIGUSR1 and pause
                    sigsuspend(&oldmask);
                    if (sigusr1) {
                        nb++;
                        sigusr1 = 0;
                    }
                }
                printf("[%d] oui j'arrivee au bout de %d times\n" , getpid() , nb);
                return 0 ; 
            case -1:
                perror("fork");
                exit(EXIT_FAILURE);
            default:
                break;    
        }
    }
    srandom(getpid());
    errno = 0 ; 
    do{
        int r = random()%5;
        kill(0, SIGUSR1);
        sleep(1);
        waitpid(-1 , NULL , WNOHANG);
    }while(errno != ECHILD);
    return 0;
}
