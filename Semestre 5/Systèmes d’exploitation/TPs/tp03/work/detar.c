#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include "tarutils.h"
#include <assert.h>

#define MIN(a,b) (((a)<(b))?(a):(b))

char buf[BLOCKSIZE];
struct posix_header hd;

/* extraie de l'archive dont fd est un descripteur le fichier décrit par
 * l'entête phd : crée un fichier de nom phd -> name
 * et de contenu constitué des filesize octets suivants de l'archive.
 * Attention à respecter les droits phd -> mode */
int extract(int fd, struct posix_header * phd, unsigned int filesize) {

  /* TODO : vérification du type de fichier : seuls les REGTYPE et AREGTYPE 
   * sont supportés */
  if (phd->typeflag != '0' && phd->typeflag != '\0') return 1 ; 

  
  /* TODO : création du fichier avec les bons droits */
  int tmp ; 
  if (sscanf(phd->mode , "%o" , &tmp) != 1) return 1 ; 
  int fd_new = open(phd->name , O_WRONLY | O_CREAT , tmp) ; 

  /* TODO : recopie du contenu; ATTENTION au dernier bloc! */ 
  unsigned int nbblocksData = (filesize + BLOCKSIZE - 1) / BLOCKSIZE ;
  for (unsigned int i = 0 ; i<nbblocksData ; i++) {
    int read_val = read(fd , buf , BLOCKSIZE*sizeof(char)) ; 
    if (read < 0) {
      close(fd_new) ; 
      return 1 ; 
    }
    int write_val = write(fd_new , buf , MIN(filesize , BLOCKSIZE)*sizeof(char)) ;
    if (write_val != MIN(filesize , read_val)) {
      close(fd_new) ; 
      return 1 ; 
    } 
    filesize-= write_val ; 
  }

  /* TODO : refermer le descripteur */
  close(fd_new) ; 
  return 0;
}


int main(int argc, char **argv){
  int ret = 0, all;
  char * filename = NULL;
  struct posix_header * phd = &hd;

  switch (argc) {
    case 2 : all = 1; break;
    case 3 : all = 0; filename = argv[2]; break;
    default :
      fprintf(stderr, "Usage : %s file.tar [file]\n", argv[0]);
      exit(1);
  }
  /* TODO : ouverture du fichier tar */
  int fd = open(argv[1] , O_RDONLY) ; 
  if (fd < 0) {
    return 1 ; 
  }

  /* boucle principale */
  while (1) {
    /* TODO : lecture de l'entête; vérifier que la lecture est bien complète */
    ssize_t read_val = read(fd , phd , BLOCKSIZE) ; 
    if (read_val < 0) {
      close(fd) ; 
      return 1 ; 
    }

    /* TODO : la fin de l'archive est atteinte si le bloc est rempli de zéros, 
     * et en particulier si name == "" */
    if (*(phd->name) == '\0') break;

     /* vérification de checksum (facultatif) */
    //  if (!check_checksum(phd)) {
    //    fprintf(stderr, "Checksum erronée : %s\n", phd -> chksum);
    //    ret = 1;
    //    break;
    //  }

    /* TODO : la taille et le nombre de blocs sont toujours utiles */
    unsigned int filesize ; 
    unsigned int nbblocks = (filesize+BLOCKSIZE-1)/BLOCKSIZE ; 
    if (sscanf(phd->size , "%o" , &filesize) != 1) {
      close(fd) ; 
      return 1 ; 
    } 

    /* TODO[1] s'il s'agit du fichier cherché, le désarchiver puis
     * quitter; sinon, sauter à l'entête suivant */ 
    if (all) {
      ret = extract(fd , phd , filesize) ; 
      if (ret) {
        close(fd) ; 
        return ret ; 
      }
      continue;
    }
    if (!strcmp(phd->name , filename)) {
      ret = extract(fd , phd , filesize) ;
      if (ret) {
        close(fd) ; 
        return ret ; 
      } 
    }
    lseek(fd , nbblocks*BLOCKSIZE , SEEK_CUR) ; 


    /* TODO[2] s'il s'agit d'une extraction complète (all == 1),
     * désarchiver le fichier et continuer (sauf en cas d'erreur)*/


  }

  /* TODO : fermeture du fichier tar */
  close(fd) ; 

  exit(ret);
}
