# TP nº5 : A Long Walk along The Filesystem

**L3 Informatique - Système**

Ce TP permet d'approfondir les parcours d'arborescences. Pour cela, nous
allons programmer une commande pour trouver un fichier à partir d'un
emplacement donné.
Le parcours d'arborescence à faire est un parcours récursif descendant.

#### Instructions pour faire le TP

1. Mettez à jour le dépôt `git` du cours. Placez-vous dans le
   répertoire du cours et lancez la commande `git pull`.
2. Déplacez-vous dans le répertoire `TP/TP5/`.
3. Lancez la commande `make init` pour initialiser le répertoire de
   travail.
4. Déplacez-vous dans le répertoire `work` pour travailler.

#### Exercice 1 : `mystring`, mini-bibliothèque de chaînes de caractères

Pour l'exercice 2, vous aurez besoin d'effectuer les deux opérations
suivantes sur des chaînes de caractères :

 * Ajout de caractères supplémentaires à la fin,
 * Troncature, c'est-à-dire suppression d'un certain nombre de caractères à la fin.
 
La mini-bibliothèque de manipulation de chaînes de caractères est à completer.

`TODO:` Déplacez-vous dans le répertoire `work/findp`. Lisez le fichier
`mystring.h` pour regarder brièvement les fonctions à utiliser.
Dans le fichier `mystring.c`, écrivez le code de la fonction `string_append`.


#### Exercice 2 : `findp`, trouver l'emplacement d'un fichier

Nous allons programmer une version simplifiée de la commande `find`, qui
se contentera d'une recherche selon le critère du nom (_basename_) : on
souhaite que `findp dir_name target_name` soit un équivalent de `find
dir_name -name target_name`.

Le principe de l'algorithme est simple. Intuitivement, il faut lister
toutes les entrées d'un répertoire, et pour chaque entrée, vérifier si
elle porte le nom cherché; par ailleurs, s'il s'agit d'un répertoire, il
faut poursuivre la recherche dedans.

Déplacez-vous dans le répertoire `work/findp`.

1. Complétez la fonction `main` de `findp.c`. Votre programme doit  retourner 
   une erreur si l'argument donné en paramètre n'existe pas et si ce n'est pas 
   un répertoire. Dans le cas contraire, le programme doit appeler la fonction
   `process_dir` qui recherche les fichiers `target_name` récursivement dans 
   le répertoire `path` (`TODO[1]`).

2. Complétez la fonction `process_dir` de `findp.c`. Cette fonction doit
   parcourir le répertoire `path` en argument. Dans un premier temps,
   constituez le corps de la fonction qui parcourt les entrées du 
   répertoire (`TODO[2]`).

3. Pour chaque entrée du répertoire, tester si le fichier coïncide avec
   celui qui est recherché (`TODO[3]`) et effectuez l'affichage de `findp`.

4. Il faut maintenant implémenter la recherche récursive; pour cela, nous
   avons besoin de construire les chemins des sous-répertoires à
   explorer. Pour chercher dans un sous-répertoire, il faut concaténer
   son nom au chemin en cours d'inspection et le supprimer quand nous avons
   fini de le traiter. Sans cela, nous n'aurons pas le bon chemin pour
   inspecter les fichiers du sous-répertoire. Implémentez la recherche
   dans les sous-répertoires (`TODO[4]`). Attention, la fonction `readdir`
   ne conserve pas sa position si le répertoire a été fermé avec `closedir`.

5. Assurez-vous que votre programme termine avec un code de retour de `0`
   s'il a trouvé des fichiers portant le nom cherché, et `1` sinon (`TODO[5]`).
    
6. Testez votre code avec la commande `make test`.


#### Exercice 3 : `untar`, reproduire une arborescence

Dans les exercices 2 et 3 du TP nº3, vous avez extrait et produit des
archives simples formées uniquement de fichiers ordinaires (sans
répertoires). Nous allons maintenant programmer un petit outil pour
extraire des archives `tar` plus générales.

0.
    - Si vous avez fini l'exercice 2 du TP3, renommez le fichier `untar.c`
      en `untar.c.alt`, puis copiez votre code du TP3, exercice 2,
      (`../TP3/work/detar.c`) en `work/untar/untar.c`.
     
    - Sinon, vous pouvez utiliser le fichier source : `work/untar/untar.c`.  
   
   Déplacez-vous dans le répertoire `work/untar` pour la suite de l'exercice.

1. Consulter (avec `hexdump -C` par exemple, ou `tar tf`) une archive
   `tar` représentant une petite arborescence, par exemple :
   
   ```sh
   tata/
   ├── titi
   ├── toto
   └── tutu
       └── toutou
   ```
   Que faudra-t-il faire pour reproduire cette arborescence lors de 
   l'extraction ? 

2. Modifier le code pour prendre en charge l'extraction de répertoire (`TODO`).

3. Lancer le test avec la commande `make check`.



#### Exercice 4 : `mktar`, archiver une arborescence.

Dans cet exercice, on modifie `mktar` pour archiver des répertoires.

Déplacez-vous dans le répertoire `work/mktar`.

1. Que faut-il faire pour reproduire une arborescence de répertoires dans
   une archive `tar`? Combien de blocs sont nécessaires à l'archivage
   d'un répertoire?

2. Modifier la fonction `tar_file` du fichier `mktar.c` afin qu'elle archive
   le fichier/répertoire passé en paramètre (`TODO[1]`).

3. Modifier la fonction `process` du fichier `mktar.c` afin qu'elle archive le
   chemin passé en paramètre et que, si c'est un répertoire, elle parcoure
   récursivement l'arborescence pour archiver les fichiers du répertoire
   (`TODO[2]`).

4. Archiver le répertoire `test0` avec votre programme et vérifier qu'il
   fonctionne correctement avec votre programme `untar` de l'exercice 2.

